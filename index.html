---
root: .
title: Revel на русском | Веб фреймворк на языке Go (golang)
---
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8"> 
    {% include head.html %}
    <link href="{{ page.root }}/css/prettify.css" type="text/css" rel="stylesheet" />
    <script src="{{ page.root }}/js/prettify.js" type="text/javascript"></script>
    <script src="{{ page.root }}/js/lang-go-rich.js" type="text/javascript"></script>
    {% include analytics.html %}
  </head>

  <body onload="prettyPrint()">
    <a href="https://github.com/gorevelru/gorevelru.github.io">
      <img style="position: absolute; top: 0; right: 0; border: 0; z-index:1000;"
           src="img/forkme_right_orange_ff7600.png" alt="Помочь с переводом"></a>

    {% include topnav.html %}

    <header class="hero-unit">
      <div class="container">
        <div class="row" style="margin-left:-50px;">
          <div class="hero-img"><img src="img/RevelWhiteLines.png" height="500" width="350"></div>
          <div class="hero-text">
            <h1>Revel</h1>
            <p>Высокопроизводительный веб фреймворк на языке Go (golang).</p>
            <p>Перевод сайта <a href="http://revel.github.io/">revel.github.io</a></p>
          </div>
        </div>
      </div>
    </header>

    <div class="container">
      <div class="page-header">
        <h1>Особенности</h1>
      </div>
      <div class="row">
        <div class="span4">
          <h2>Быстрая разработка</h2>
          <p>
            Редактируйте, сохраняйте и обновляйте.  Ревел компилирует ваш код и шаблоны для вас,
            так что вы не пропустите ниодной детали.  Код не компилится?  Вы получите
            <a href="img/CompilationError.png">подробное описание</a>.
            Ошибка времени выполнения?  Revel <a href="img/Panic.png">
            сообщит вам </a>.
          </p>
        </div>
        <div class="span4">
          <h2>Богатая поставка</h2>
          <p>
            Revel включает
            <a href="manual/routing.html">маршрутизацию</a>,
            <a href="manual/binding.html">получение параметров</a>,
            <a href="manual/validation.html">валидацию</a>,
            <a href="manual/sessionflash.html">сессии</a>,
            <a href="manual/templates.html">шаблоны</a>,
            <a href="manual/cache.html">кеширование</a>,
            <a href="manual/jobs.html">задачи</a>,
            <a href="manual/testing.html">тестирование</a>,
            и даже <a href="manual/i18n-messages.html">интернационализацию</a>.
          </p>
        </div>
        <div class="span4">
          <h2>Быстрое выполнение</h2>
          <p>
            Revel работает на HTTP сервере Go, который, по последним 
            <a href="http://www.techempower.com/benchmarks/#section=data-r9">замерам
            производительности</a> обгоняет Ruby on Rails в <b>10–50 раз</b> на
            различных нагрузках.
          </p>
        </div>
      </div>
      <div class="page-header">
        <h1>Дизайн</h1>
      </div>
      <div class="row">
        <div class="span4">
          <h2>Синхронный</h2>
          <p>
            В <a href="http://golang.org/pkg/net/http/">HTTP сервере Go</a>
            каждый запрос выполняется в отдельной
            <a href="http://golang.org/doc/effective_go.html#goroutines">горутине</a>.
            Пишите простой код без колбеков и головной боли.
          </p>
        </div>
        <div class="span4">
          <h2>Без состояния</h2>
          <p>
            Revel предоставляет примитивы для построения веб приложений без состояния
            для предсказуемого масштабирования. Например, данные пользовательских
            сессий хранятся в куках, а закешированные данные – в кластере memcached.
          </p>
        </div>
        <div class="span4">
          <h2>Модульный</h2>
          <p>
            Revel is built around composable middleware called <b>filters</b>,
            which implement nearly all request-processing
            functionality. Developers have the freedom to replace the default
            filters with custom implementations (e.g. a custom router).
          </p>
        </div>
      </div>
      <div class="row">
      </div>
      <section id="quickstart">
        <div class="page-header">
          <h1>Быстрый старт</h1>
        </div>
        <div class="row">
          <div class="span6">
            <p>
              Revel поставляется с простыми ознакомительными приложениями.
            </p>
            <p>
              Вы должны иметь <a href="http://golang.org/doc/install">работающий Go 1.2
              </a> для Revel.
            </p>
            <p>
              Команды справа:
              <ol>
                <li>Установят Revel в ваш GOPATH
                <li>Скомпилируют Revel
                <li>Запустят пример чата
              </ol>
              После запуска, откройте в браузере
              <a href="http://localhost:9000/">http://localhost:9000/</a>, и
              <a href="samples/chat.html">узнайте как чат функционирует</a>.
            </p>
          </div>
          <div class="span6" style="vertical-align:bottom;">
            <pre>
  go get github.com/revel/cmd/revel
  revel run github.com/revel/revel/samples/chat
            </pre>
          </div>
        </div>
      </section>

      <section id="development">
        <div class="page-header">
          <h1>Состояние разработки</h1>
        </div>
        <p>
          Разработка приближается к "финальной" версии 1.0, но количество вносимых изменений все еще большое.
           Готовьтесь пачкать руки.
        </p>
        <p style="font-weight:bold;">
          Присоединяйтесь к нашей <a href="https://groups.google.com/forum/#!forum/revel-framework">Google Group</a>,
          что бы принять участие в разработке, или в IRC на 
          <a href="http://webchat.freenode.net/?channels=revel&amp;uio=d4">Freenode #revel</a>.
        </p>
        <p>
          <a href="https://twitter.com/revelframework" class="twitter-follow-button" data-show-count="false" data-size="large">Follow @revelframework</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

          <a href="https://twitter.com/share" class="twitter-share-button" data-via="revelframework" data-size="large" data-count="none" data-hashtags="golang">Tweet</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
        </p>
      </section>

      <section id="teaser">
        <div class="page-header">
          <h1>Обзор</h1>
        </div>
        <p>
          Этот раздел даст вам попробовать различные части фреймоврка:
        </p>

        <dl class="dl-horizontal">
          <dt><a href="#routing">Маршруты</a></dt>
          <dd>Простой декларативный синтаксис. Типобезопасная обратная маршрутизация.</dd>

          <dt><a href="#controllers">Контроллеры</a></dt>
          <dd>
            Revel поддерживает endpoints в Контроллерах. Они обеспечивают легкую 
            привязку данных и проверку форм.
          </dd>

          <dt><a href="#templates">Шаблоны</a></dt>
          <dd>Revel делает Go шаблоны простыми в использовании и масштабируемыми.</dd>

          <dt><a href="#interceptors">Перехватчики</a></dt>
          <dd>
            Регистрируйте функции для вызова до и после действий.  Они могут быть
            определены отдельно для каждого Контроллера.
          </dd>

          <dt><a href="#filters">Фильтры</a></dt>
          <dd>
            Большая функциональность достигается при помощи Фильтров.
          </dd>

        </dl>

        <div class="row">
          <div class="span6">
            <h2 id="routing">Маршрутизация</h2>
            <p>
              Revel использует декларативный синтаксис. Все маршруты для приложения находятся в одном файле
               с простым синтаксисом для проверки совпадания
              , извлечения параметров из урла и указания конкретного действия.
              Ниже находится пример с комментариями.
            </p>
          </div>
          <div class="span12">
            <pre>
# conf/routes
# Этот файл содержит все маршруты для приложения (Первые записи имеют больший приоритет)
GET    /login                Application.Login       <b># Простой путь</b>
GET    /hotels/              Hotels.Index            <b># Совпадение с или без слеша в конце</b>
GET    /hotels/:id           Hotels.Show             <b># Получение и передача аргумента</b>
WS     /hotels/:id/feed      Hotels.Feed             <b># Веб сокет</b>
POST   /hotels/:id/:action   Hotels.:action          <b># Автоматический маршрут с некоторым действием</b>
GET    /public/*filepath     Static.Serve("public")  <b># Assets served from /public/...</b>
*      /:controller/:action  :controller.:action     <b># Ловит все; автоматически генерит урлы</b></pre>

          </div>
          <div class="span6">
						<p>
							Обратные маршруты могут быть сгенерированы в типобезопасной манере.  Например:
						</p>
          </div>
          <div class="span12">
            <pre class="prettyprint lang-go">
// Вывод информации об отелях.
func (c Hotels) Show(id int) revel.Result {
	hotel := HotelById(id)
	return c.Render(hotel)
}

// Загрузка информации и редирект на страницу вывода.
func (c Hotels) Save(hotel Hotel) revel.Result {
	// проверка и сохранение отеля
	return c.Redirect(<b>routes.Hotels.Show(hotel.Id)</b>)
}</pre>
					</div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="controllers">Контроллеры</h2>
            <p>
              Все действия это методы в контроллере. Несколько классных вещей:
              <ul>
                <li> <b>Привязка данных.</b>  Revel связывает простые значения и части урла или формы
                  и передает их в качестве параметров в ваш метод.
                  (If you prefer to access them directly from a parameter map, that's ok too!)
                <li> <b>Валидация.</b> Хелперы управляют ошибками валидации.
                <li> <b>Flash.</b> The flash is a cookie that lives for one
                  request (errors, success messages, etc).
                <li> <b>Сессии.</b> Сессии это криптографические
                  cookie, вида <code>map[string]string</code>.
                <li> <b>Results.</b> Redirections take advantage of reverse
                  routing.  Template rendering makes your data available using the
                  name of the local variable!
              </ul>

              Пример:
            </p>
          </div>

          <div class="span12">
            <pre class="prettyprint lang-go">
// app/controllers/app.go

type Application struct {
	*revel.Controller
}

func (c Application) Register() revel.Result {
	title := "Register"
	return c.Render(title)
}

func (c Application) SaveUser(user models.User, verifyPassword string) revel.Result {
	c.Validation.Required(verifyPassword)
	c.Validation.Required(verifyPassword == user.Password)
		Message("Password does not match")
	user.Validate(c.Validation)

	if c.Validation.HasErrors() {
		c.Validation.Keep()
		c.FlashParams()
		return c.Redirect(routes.Application.Register())
	}

	user.HashedPassword, _ = bcrypt.GenerateFromPassword(
		[]byte(user.Password), bcrypt.DefaultCost)
	err := c.Txn.Insert(&user)
	if err != nil {
		panic(err)
	}

	c.Session["user"] = user.Username
	c.Flash.Success("Welcome, " + user.Name)
	return c.Redirect(routes.Hotels.Index())
}
            </pre>
          </div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="templates">Шаблоны</h2>
            <p>
              В соответствии с соглашением, Revel легко интегрирует 
              <a href="http://golang.org/pkg/text/template/">Go Templates</a>
              в остальные части веб приложения. Ниже представлена часть шаблона
              показывающая <b>Регистрацию</b> из примера выше.
            </p>
            Note that:
            <ul>
              <li> Revel found it automatically using the name of the action.
              <li> <b>field</b> is a simple helper function that returns a map
                of validation errors and parameter values for the named field.
                The app may inject any helper funcs that it wants.
              <li> The <b>title</b> variable is available in the template as if
                it had been explicitly put in the RenderArgs.  (It's used in
                <a href="http://github.com/revel/revel/samples/booking/app/views/header.html">
                  header.html</a> in this case)
            </ul>
          </div>

          <div class="span12">
            <pre class="prettyprint lang-html">{% capture teaser_template %}{% raw %}
{{/* app/views/Application/Register.html */}}

{{template "header.html" .}}

<h1>Register:</h1>
<form action="/register" method="POST">
  {{with $field := field "user.Username" .}}
    <p class="{{$field.ErrorClass}}">
      <strong>Username:</strong>
      <input type="text" name="{{$field.Name}}" size="16" value="{{$field.Flash}}"> *
      <span class="error">{{$field.Error}}</span>
    </p>
  {{end}}

  {{/* other fields */}}

  <p class="buttons">
    <input type="submit" value="Register"> <a href="/">Cancel</a>
  </p>
</form>

{{template "footer.html" .}}{% endraw %}{% endcapture %}{{ teaser_template|escape }}</pre>
          </div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="interceptors">Interceptors</h2>
            <p>
              Interceptors are controller methods that are run before or after
              requests, or in response to panics.  By embedding a controller
              into another, a developer can share interceptors and fields across
              many controllers.
            </p>
						<p>
							As an example, the database module may be used to open a
							connection on initialization, made available through a global
							handle.  Additionally, embedding the <b>db.Transactional</b> type
							adds a <b>sql.Txn</b> field plus interceptors that begin and commit
							transactions (or rollback on panic).
						</p>
						<p>
							Here's what the interceptor looks like (minus error handling):
						</p>
          </div>

          <div class="span12">
            <pre class="prettyprint">
// github.com/revel/revel/modules/db/app/db.go

var Db *sql.DB

func Init() {
	// Read configuration.
	Driver, _ = revel.Config.String("db.driver")
	Spec, _ = revel.Config.String("db.spec")

	// Open a connection.
	Db, _ = sql.Open(Driver, Spec)
}

// Transactional adds transaction management to your controller.
type Transactional struct {
	*revel.Controller
	Txn *sql.Tx
}

func (c *Transactional) Begin() revel.Result {
	c.Txn, _ = Db.Begin()
	return nil
}

func (c *Transactional) Commit() revel.Result {
	_ = c.Txn.Commit()
	c.Txn = nil
	return nil
}

func (c *Transactional) Rollback() revel.Result {
	_ = c.Txn.Rollback()
	c.Txn = nil
	return nil
}

func init() {
	revel.InterceptMethod((*Transactional).Begin, revel.BEFORE)
	revel.InterceptMethod((*Transactional).Commit, revel.AFTER)
	revel.InterceptMethod((*Transactional).Rollback, revel.PANIC)
}</pre>

						<p>
							Here is how it can be mixed in to an application controller:
						</p>

            <pre class="prettyprint">
type Bookings struct {
	*revel.Controller
	db.Transactional  // Adds .Txn
	user.Login        // Adds .User
}

func (c Bookings) ShowFirstBooking() revel.Result {
	row := c.Txn.QueryRow(`
select id, hotel_id, user_id, price, nights
  from Booking
 where UserId = ?
 limit 1`, c.User.Id)
	...
	return c.Render(booking)
}</pre>
          </div>
        </div>

        <div class="row">
          <div class="span6">
            <h2 id="filters">Filters</h2>
            <p>
              Filters are the middleware of the application.  They are simply
              funcs with a specific signature:
            </p>
            <pre class="prettyprint">
type Filter func(c *Controller, filterChain []Filter)</pre>
            <p>
              Even complicated "built-in" functionality like the interceptor
              framework is implemented as a filter:
            </p>
          </div>

          <div class="span12">
            <pre class="prettyprint">
// github.com/revel/revel/intercept.go

var InterceptorFilter = func(c *Controller, fc []Filter) {
	defer invokeInterceptors(FINALLY, c)
	defer func() {
		if err := recover(); err != nil {
			invokeInterceptors(PANIC, c)
			panic(err)
		}
	}()

	// Invoke the BEFORE interceptors and return early, if we get a result.
	invokeInterceptors(BEFORE, c)
	if c.Result != nil {
		return
	}

	fc[0](c, fc[1:])
	invokeInterceptors(AFTER, c)
}</pre>
						<p>
							Revel provides a default stack of Filters which the developer can
							override.  This makes it easy for the developer to select exactly
							the parts of the framework that they want to use.
						</p>

            <pre class="prettyprint">
// github.com/revel/revel/filter.go

// Filters is the default set of global filters.
// It may be set by the application on initialization.
var Filters = []Filter{
	PanicFilter,             // Recover from panics and display an error page instead.
	RouterFilter,            // Use the routing table to select the right Action
	FilterConfiguringFilter, // A hook for adding or removing per-Action filters.
	ParamsFilter,            // Parse parameters into Controller.Params.
	SessionFilter,           // Restore and write the session cookie.
	FlashFilter,             // Restore and write the flash cookie.
	ValidationFilter,        // Restore kept validation errors and save new ones from cookie.
	I18nFilter,              // Resolve the requested language
	InterceptorFilter,       // Run interceptors around the action.
	ActionInvoker,           // Invoke the action.
}
						</pre>

						<p>
							Nearly all framework functionality is implemented in the filters,
							and the filter stack is directly exposed to the developer as part
							of the configuration.  This makes Revel understandable and modular.
						</p>
						<p>
							As proof of modularity, look how simple
							the <a href="https://github.com/revel/revel/blob/master/server.go">
								main server handler</a> is:
						</p>
            <pre class="prettyprint">
// github.com/revel/revel/server.go

func handleInternal(w http.ResponseWriter, r *http.Request, ws *websocket.Conn) {
	var (
		req  = NewRequest(r)
		resp = NewResponse(w)
		c    = NewController(req, resp)
	)
	req.Websocket = ws

	Filters[0](c, Filters[1:])
	if c.Result != nil {
		c.Result.Apply(req, resp)
	}
}</pre>
          </div>
				</div>
      </section>

      <section id="wishlist">
        <div class="page-header">
          <h1>Wishlist</h1>
        </div>
        <p>
          There are some areas that could benefit from some TLC.
        </p>
        <ul>
          <li> <b>ORM</b> -- Presently Revel is BYOORM (bring-your-own-ORM).  A
            good ORM integration would make simple things simple.
            (e.g. <a href="http://github.com/coopernurse/gorp">gorp</a>,
            <a href="https://github.com/eaigner/hood">hood</a>,
            <a href="https://github.com/coocood/qbs">qbs</a>,
            <a href="https://github.com/eaigner/jet">jet</a>,
            <a href="https://github.com/astaxie/beedb">beedb</a>,
            <a href="https://github.com/gosexy/db">gosexy</a>,
            <a href="https://github.com/jinzhu/gorm">gorm</a>)
          <li> <b>Pluggable template loader</b> -- Presently only Go templates
          are supported by Revel (although the developer could use their own
          library independently).  Providing an interface that makes any
          template language pluggable would be ideal.
        </ul>
      </section>

      <hr>

      <footer>
        <p>MIT License</p>
        <p>
          Gopher images remixed from those produced by
          <a href="http://www.golang.org">Go team</a>.
        </p>
      </footer>

    </div> <!-- /container -->
  </body>
</html>
